using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Linq;
using System.Xml.Linq;

using Microsoft.CodeAnalysis; 
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

using NSwag.CodeGeneration.CSharp;
using NSwag.CodeGeneration.Models;
using NSwag.CodeGeneration.OperationNameGenerators;
using NSwag;


namespace LazyStack
{
    /// <summary>
    /// Process the solution projects.
    /// ProcessClientProject -- openApi generation of client Api
    /// ProcessAppApiProject -- openApi generation of core application Api
    /// For Each tag
    ///     ProcessLambdaProject -- create if it doesn't exist
    ///     ProcessControllerProject -- create or update
    /// ProcessLocalWebServer -- update references when new AppApiGroupApi projects are added
    /// </summary>
    public class ProcessProjects
    {
        public ProcessProjects(SolutionModel solutionModel, ILogger logger)
        {
            this.solutionModel = solutionModel;
            this.logger = logger;
        }

        private readonly SolutionModel solutionModel;
        private readonly ILogger logger;

        public async Task RunAsync()
        {
            await ProcessClientSDKProjectAsync(); // also generates schema project

            // Generate Controller and Lambda function project for each OpenApi tag
            foreach (KeyValuePair<string, AWSLambda> lambda in solutionModel.Lambdas)
            {
                await ProcessLambdaProjectAsync(lambda.Key, lambda.Value.AwsApi); 
                await ProcessControllerProjectAsync(lambda.Key);
            }

            await ProcessLocalWebApiProjectAsync();

            // Update solutionModel.SolutionFolders
            foreach (var projInfo in solutionModel.Projects.Values)
                if (!string.IsNullOrEmpty(projInfo.SolutionFolder)
                    && !solutionModel.SolutionFolders.Contains(projInfo.SolutionFolder))
                    solutionModel.SolutionFolders.Add(projInfo.SolutionFolder);
        }

        /// <summary>
        /// Generate the <AppName>ClientSDK project.
        /// The ClientSDK is used in client applications to call the applciation stack.
        /// Note there is nothing AWS Specific in this project.
        /// Also call ProcessSchemaProject() to generate the <AppName>Schema project.
        /// The Schema project is the Models folder generated by the 
        /// ClientSDK project. We want the models to be consistent across
        /// the client and server to promote code reuse.
        /// </summary>
        private async Task ProcessClientSDKProjectAsync()
        {
            var appName = solutionModel.AppName; // PetStore
            var projName = $"{appName}ClientSDK";  // PetStoreClientSDK
            var projFileName = $"{projName}.csproj"; // PetStoreClientSDK.csproj 
            var projFileRelativePath = Path.Combine(projName, projFileName); // PetStoreClientSDK/PetStoreClientSDK.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.ClientSDK = new ProjectInfo(
                    solutionFolder: string.Empty,
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    );

            solutionModel.Projects.Add(projName, solutionModel.ClientSDK);
            solutionModel.ClientSDKProjectName = projName;

            await logger.InfoAsync($"Generating/updating {projName}");

            if(Directory.Exists(projFolderPath))
                foreach (var file in Directory.GetFiles(projFolderPath))
                    File.Delete(file);
        
            // Copy project templates with replacements and renames as necessary
            Utilities.DirectoryCopy(
                Path.Combine(solutionModel.LazyStackTemplateFolderPath, "ClientSDK"),
                projFolderPath,
                copySubDirs: true,
                overwrite: true,
                removeTplExtension: true,
                new Dictionary<string, string> {{ "__ProjName__", projName }}
                );

            // Generate client sdk class using NSwag
            var nswagSettings = new CSharpClientGeneratorSettings
            {
                ClassName = $"{appName}",
                UseBaseUrl = false,
                HttpClientType = "ILzHttpClient",
                CSharpGeneratorSettings =
                {
                    Namespace = projName,
                    GenerateDataAnnotations = false
                },
                OperationNameGenerator = new LzOperationNameGenerator()
            };

            var openApiDocument = OpenApiYamlDocument.FromYamlAsync(solutionModel.OpenApiSpecText).GetAwaiter().GetResult();

            var nswagGenerator = new CSharpClientGenerator(openApiDocument, nswagSettings);
            var code = nswagGenerator.GenerateFile();
            var schemaCode = code;

            // Strip out schema classes, insert using statement, write out final class
            var root = CSharpSyntaxTree.ParseText(code).GetCompilationUnitRoot();
            root = RemoveGeneratedSchemaClasses(root, new List<string> { "ApiException" });
            root = InsertUsingStatements(root, new List<string> { { $"{appName}Schema.Models" } });
            code = root.ToFullString();
            File.WriteAllText(Path.Combine(projFolderPath, $"{appName}.cs"), code);

            // Generate interface
            //var syntaxTree = CSharpSyntaxTree.ParseText(code);
            //var syntaxRoot = syntaxTree.GetRoot();
            //IEnumerable<InterfaceDeclarationSyntax> interfaceDeclarations = syntaxRoot.DescendantNodes().OfType<InterfaceDeclarationSyntax>();

            
            // Rename project file
            File.Move(Path.Combine(projFolderPath, "ClientSDK.csproj"), projFilePath);

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "ClientSDKProjects",
                projName,
                localProjectReferences: new List<string>
                {
                    //< ProjectReference Include = "..\PetStoreSchema\PetStoreSchema.csproj" />
                    Path.Combine("..",$"{appName}Schema", $"{appName}Schema.csproj"),
                },
                localPackageReferences: null,
                localProperties: null
                );

            // Stip out the Api classes to create schema code
            var schemaRoot = CSharpSyntaxTree.ParseText(schemaCode).GetCompilationUnitRoot();
            schemaRoot = RemoveClass(schemaRoot, appName);
            await ProcessSchemaProjectAsync(schemaRoot); // Create shcema project
        }

        private async Task ProcessSchemaProjectAsync( CompilationUnitSyntax schemaRoot)
        {
            var projName = $"{solutionModel.AppName}Schema"; // PetStoreSchema
            var projFileName = $"{projName}.csproj"; // PetStoreSchema.csproj
            var projFileRelativePath = Path.Combine(projName, projFileName); // PetStoreSchema/PetStoreSchema.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: string.Empty,
                    path: projFilePath,
                    projFileRelativePath,
                    projFolderPath
                    ));

            await logger.InfoAsync($"Generating/updating project {projName}");

            if (!Directory.Exists(projFolderPath))
            {
                Utilities.DirectoryCopy(
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Schema"),
                    projFolderPath,
                    copySubDirs: true,
                    overwrite: true,
                    removeTplExtension: true);

                File.Move( // Rename csproj file. ex Lambda.csproj to PetStoreOrderLambda.csproj
                    Path.Combine(projFolderPath, "Schema.csproj"),
                    projFilePath);

                Directory.CreateDirectory(Path.Combine(projFolderPath, "Models"));
            }

            foreach (var file in Directory.GetFiles(Path.Combine(projFolderPath, "Models")))
                File.Delete(file);

            // Generate separate files for each model class
            var classGroups = schemaRoot
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .GroupBy(x => x.Identifier.ValueText)
                    .ToList(); // ex: OrderController

            var template = @"
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain 
// </auto-generated>
// Refactored into the schema project by LazyStack
//----------------------

#pragma warning disable 108 // Disable ""CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'.Use the new keyword if hiding was intended.""
#pragma warning disable 114 // Disable ""CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.""
#pragma warning disable 472 // Disable ""CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'""
#pragma warning disable 1573 // Disable ""CS1573 Parameter '...' has no matching param tag in the XML comment for ...""
#pragma warning disable 1591 // Disable ""CS1591 Missing XML comment for publicly visible type or member ...""
#pragma warning disable 8073 // Disable ""CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'""

namespace __NameSpace__
{
    using System = global::System;

 __Body__
}
#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore  472
#pragma warning restore  114
#pragma warning restore  108
";

            foreach (var classGroup in classGroups)
            {
                var classFileContent = template.Replace("__NameSpace__", $"{projName}.Models");
                var className = classGroup.Key;
                var classCode = string.Empty;
                foreach(var classDecl in classGroup.ToList())
                    classCode += classDecl.ToFullString();
                classFileContent = classFileContent.Replace("__Body__", classCode);
                File.WriteAllText(Path.Combine(projFolderPath, "Models", $"{className}.cs"), classFileContent);
            }

            // Generate a separate file for each enum class
            var enumGroups = schemaRoot
            .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
            .First()
                ?.DescendantNodes().OfType<EnumDeclarationSyntax>()
                .GroupBy(x => x.Identifier.Value)
                .ToList(); // ex: OrderController

            foreach(var enumGroup in enumGroups)
            {
                var enumFileContent = template.Replace("__NameSpace__", $"{projName}.Models");
                var enumName = enumGroup.Key;
                var enumCode = string.Empty;
                foreach(var enumDecl in enumGroup.ToList())
                    enumCode += enumDecl.ToFullString();
                enumFileContent = enumFileContent.Replace("__Body__", enumCode);
                File.WriteAllText(Path.Combine(projFolderPath, "Models", $"{enumName}.cs"), enumFileContent);
            }
        }

        /// <summary>
        /// Generate the Lambdas/<LambdaName>Lambda project.
        /// </summary>
        /// <param name="lambdaName"></param>
        /// <paramref name="api"/>
        /// <paramref name="tempApiSolutionPath"/>
        /// 
        private async Task ProcessLambdaProjectAsync(string lambdaName, AwsApi api)
        {
            // Create Lambda project
            // LazyStack Templates contains a simple project fileset that we copy and 
            // modify to create the Func project. The Func project will reference the
            // <LambdaName>Api project. Programmers do not need to add anything to
            // these projects.
            var projName = $"{lambdaName}";
            var projFileName = $"{projName}.csproj";
            var projFileRelativePath = Path.Combine("Lambdas", projName, projFileName);
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, "Lambdas", projName);
            var projFilePath = Path.Combine(projFolderPath, $"{lambdaName}.csproj");

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: "Lambdas",
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    ));

            await logger.InfoAsync($"Generating/updating project {projName}");

            if (!Directory.Exists(projFolderPath))
            {
                Utilities.DirectoryCopy(
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda"),
                    projFolderPath,
                    copySubDirs: true,
                    overwrite: true,
                    removeTplExtension: true);

                File.Move( // Rename csproj file. ex Lambda.csproj to PetStoreOrderLambda.csproj
                    Path.Combine(projFolderPath, "Lambda.csproj"),
                    projFilePath);
            }

            var configureSvcsFilePath = Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda", "ConfigureSvcs.cs.tpl");
            var configureSvcsText = File.ReadAllText(configureSvcsFilePath);
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(configureSvcsText).GetCompilationUnitRoot();

            var serviceStatements = solutionModel.GetConfigPropertyItems($"LambdaProjects/ServiceRegistrations", errorIfMissing: false);
            var serviceStatements2 = solutionModel.GetConfigPropertyItems($"{projName}/ServiceRegistrations", errorIfMissing: false);
            foreach (var stmt in serviceStatements2)
                if (!serviceStatements.Contains(stmt))
                    serviceStatements.Add(stmt);
            FormatServiceStatements(serviceStatements);

            root = InsertServiceRegistrations(root, serviceStatements);
            configureSvcsText = root.ToFullString();
            var filePath = Path.Combine(projFolderPath, "ConfigureSvcs.cs");
            File.WriteAllText(filePath, configureSvcsText);


            // Update LambdaEntryPoint class to inherit correct base class for specified HttpApi or Api
            // We do this every time because it is not unusual to change the tag/api mapping
            var text = File.ReadAllText(Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda", "LambdaEntryPoint.cs.tpl"));
            var baseClass = api.ProxyFunctionName;
            text = text.Replace("__APIGatewayProxyFunction__", baseClass);
            var lamdbaEntryPointFilePath = Path.Combine(projFolderPath, "LambdaEntryPoint.cs");
            File.WriteAllText(lamdbaEntryPointFilePath, text);

            var localProjectReferences =
                new List<string>
                {
                    //< ProjectReference Include = "..\..\Controllers\OrderController\OrderController.csproj" />
                    Path.Combine("..","..","Controllers",$"{lambdaName}Controller", $"{lambdaName}Controller.csproj")
                };

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "LambdaProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );

        }

        /// <summary>
        /// Generate a <LambdaName></LambdaName>Controller project.
        /// </summary>
        /// <param name="lambdaName"></param>
        private async Task ProcessControllerProjectAsync(string lambdaName)
        {
            var appName = solutionModel.AppName; // PetStore
            var projName = $"{lambdaName}Controller"; // OrderController
            var projFileName = $"{projName}.csproj"; // OrderController.csproj
            var projFileRelativePath = Path.Combine("Controllers", projName, projFileName); // Controllers/OrderController/OrderController.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, "Controllers", projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: "Controllers",
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    ));

            await logger.InfoAsync($"Generating/updating project {lambdaName}Controller");

            // Create new project folder if it doesn't exist
            if (!Directory.Exists(projFolderPath))
                Directory.CreateDirectory(projFolderPath);

            File.Copy(Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Controllers", "Controller.csproj"),
                projFilePath, overwrite: true);

            var fileText = File.ReadAllText(Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Controllers", "FakeEntryPoint.cs.tpl"));
            fileText = fileText.Replace("__NameSpace__", projName);
            File.WriteAllText(Path.Combine(projFolderPath, "FakeEntryPoint.cs"), fileText);

            var lambda = solutionModel.Lambdas[lambdaName];
            var openApiSpec = SolutionModel.YamlNodeToText(lambda.OpenApiSpec);
            var openApiDocument = OpenApiYamlDocument.FromYamlAsync(openApiSpec).GetAwaiter().GetResult();

            var cSharpControllerGeneratorSettings = new CSharpControllerGeneratorSettings()
            {
                UseActionResultType = true,
                 
                ClassName = lambdaName,
                ControllerTarget = NSwag.CodeGeneration.CSharp.Models.CSharpControllerTarget.AspNetCore,
                ControllerBaseClass = "Microsoft.AspNetCore.Mvc.Controller",
                 
                CSharpGeneratorSettings =
                {
                    Namespace = projName,
                }
            };

            var controllerTarget = new CSharpControllerGenerator(openApiDocument, cSharpControllerGeneratorSettings);
            var code = controllerTarget.GenerateFile();

            var root = CSharpSyntaxTree.ParseText(code).GetCompilationUnitRoot();

            // Strip out schema classes, insert using statement, write out result
            root = RemoveGeneratedSchemaClasses(root); 
            root = InsertUsingStatements(root, new List<string> { { $"{appName}Schema.Models" } });
            code = root.ToFullString();
            // NSwag seems to have a template bug. Microsoft.AspNetCore.Mvc.HttpGET should be Microsoft.AspNetCore.Mvc.HttpGet
            code = code.Replace("Microsoft.AspNetCore.Mvc.HttpGET", "Microsoft.AspNetCore.Mvc.HttpGet");
            code = code.Replace("Microsoft.AspNetCore.Mvc.HttpPUT", "Microsoft.AspNetCore.Mvc.HttpPut");
            code = code.Replace("Microsoft.AspNetCore.Mvc.HttpPOST", "Microsoft.AspNetCore.Mvc.HttpPost");
            code = code.Replace("Microsoft.AspNetCore.Mvc.HttpUPDATE", "Microsoft.AspNetCore.Mvc.HttpUpdate");
            code = code.Replace("Microsoft.AspNetCore.Mvc.HttpDELETE", "Microsoft.AspNetCore.Mvc.HttpDelete");
            File.WriteAllText(Path.Combine(projFolderPath, $"{lambdaName}Controller.cs"), code);

            var localProjectReferences =
                new List<string> {
                    //< ProjectReference Include = "..\PetStoreSchema\PetStoreSchema.csproj" />
                    Path.Combine("..","..",$"{appName}Schema", $"{appName}Schema.csproj"),
                };

            // Modify csproj 
            UpdateProjectFile(
                projFilePath,
                "ControllerProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );
        }

        private async Task ProcessLocalWebApiProjectAsync()
        {
            // Local web server
            var appName = solutionModel.AppName;
            var projName = appName;
            var projFileName = $"{projName}.csproj";
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, appName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            await logger.InfoAsync($"Updating project {appName}");

            var configureSvcsFilePath = Path.Combine(solutionModel.LazyStackTemplateFolderPath, "WebApi", "ConfigureSvcs.cs.tpl");
            var configureSvcsText = File.ReadAllText(configureSvcsFilePath);
            configureSvcsText = configureSvcsText.Replace("__NameSpace__", projName);
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(configureSvcsText).GetCompilationUnitRoot();

            var serviceStatements = solutionModel.GetConfigPropertyItems($"WebApiProjects/ServiceRegistrations", errorIfMissing: false);
            var serviceStatements2 = solutionModel.GetConfigPropertyItems($"{projName}/ServiceRegistrations", errorIfMissing: false);
            foreach (var stmt in serviceStatements2)
                if (!serviceStatements.Contains(stmt))
                    serviceStatements.Add(stmt);
            FormatServiceStatements(serviceStatements);

            root = InsertServiceRegistrations(root, serviceStatements);
            configureSvcsText = root.ToFullString();
            var filePath = Path.Combine(projFolderPath, "ConfigureSvcs.cs");
            File.WriteAllText(filePath, configureSvcsText);


            var localProjectReferences = new List<string>();
            foreach (var lambdaName in solutionModel.Lambdas.Keys)
                // ex: <ProjectReference Include="..\Controllers\OrderController\OrderController.csproj"/>
                localProjectReferences.Add(Path.Combine("..", "Controllers", $"{lambdaName}Controller", $"{lambdaName}Controller.csproj"));

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "WebApiProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );
        }

        private CompilationUnitSyntax RemoveClass(CompilationUnitSyntax root, string className)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .ToList(); // ex: OrderController

            root = root.ReplaceNode(root,
                root.RemoveNodes(classDecls, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        private CompilationUnitSyntax RemoveGeneratedSchemaClasses(CompilationUnitSyntax root, List<string> namedClasses = null)
        {

            var test = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.AttributeLists.First().ToString().StartsWith(@"[System.CodeDom.Compiler.GeneratedCode(""NJsonSchema"))
                    .ToList();

            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.AttributeLists.First().ToString().StartsWith(@"[System.CodeDom.Compiler.GeneratedCode(""NJsonSchema"))
                    .ToList(); // ex: OrderController

            root = root.ReplaceNode(root,
                root.RemoveNodes(classDecls, SyntaxRemoveOptions.KeepNoTrivia));

            var enumDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .First()
                    ?.DescendantNodes().OfType<EnumDeclarationSyntax>()
                    .ToList(); // ex: OrderController

            root = root.ReplaceNode(root,
                root.RemoveNodes(enumDecls, SyntaxRemoveOptions.KeepNoTrivia));


            // Remove any classes in the namedClasses list
            if (namedClasses != null)
            {
                classDecls = root
                    .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                    .First()
                        ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                        .Where(x => namedClasses.Contains(x.Identifier.ValueText.ToString()))
                        .ToList();
                root = root.ReplaceNode(root,
                    root.RemoveNodes(classDecls, SyntaxRemoveOptions.KeepNoTrivia));
            }
            return root;
        }

        private void FormatServiceStatements(List<string> serviceStatements)
        {
            for (int i = 0; i < serviceStatements.Count; i++)
                serviceStatements[i] = $"            {serviceStatements[i]}\n";
        }

        private CompilationUnitSyntax InsertServiceRegistrations(CompilationUnitSyntax root, List<string> serviceStatements)
        {
            // Update ConfgiureSvcs.cs 
            var projServices = new Dictionary<string, bool>();
            foreach (var key in solutionModel.Lambdas.Keys)
                projServices.Add(key + "Controller", false); // bool indicates if the reference has been registered in the Startup.ConfigureSvcs method

            var method = root
                .DescendantNodes().OfType<ClassDeclarationSyntax>()
                .Where(x => x.Identifier.Text.Equals("Startup"))
                .FirstOrDefault()
                    ?.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Identifier.Text.Equals("ConfigureSvcs")
                            && x.ParameterList.Parameters.Count == 1
                            && x.ParameterList.Parameters[0].Type.ToString().Equals("IServiceCollection"))
                    .First();

            if (method == null)
                throw new Exception("Error: Missing Startup.ConfigureSvcs method");

            var serviceRegistrations = method.DescendantNodes().OfType<BlockSyntax>()
                .First()
                ?.DescendantNodes().OfType<ExpressionStatementSyntax>()
                .Where(x =>
                       (((x.Expression as InvocationExpressionSyntax))?.Expression is MemberAccessExpressionSyntax)
                       && ((((x.Expression as InvocationExpressionSyntax))
                               ?.Expression as MemberAccessExpressionSyntax).Expression as IdentifierNameSyntax)
                                   .Identifier.ValueText.Equals("services"));

            // Insert service registrations
            var newStatements = new List<StatementSyntax>();
            foreach (var serviceStatement in serviceStatements)
                newStatements.Add(ParseStatement(serviceStatement));

            if (newStatements.Count > 0)
                root = root.ReplaceNode(method, method.AddBodyStatements(newStatements.ToArray()));

            return root;
        }

        private CompilationUnitSyntax InsertUsingStatements(CompilationUnitSyntax root, List<string> newUsingReferences)
        {
            var existingUsingStatements = root
                .DescendantNodes().OfType<UsingDirectiveSyntax>();

            var existingUsingStatementsList = new List<string>();
            foreach (var stmt in existingUsingStatements)
                existingUsingStatementsList.Add(stmt.Name.ToString());

            foreach (var newUsingReference in newUsingReferences)
                if (existingUsingStatementsList.Count == 0 || !existingUsingStatementsList.Contains($"using {newUsingReference};"))
                {
                    var newUsingStatementTree = CSharpSyntaxTree.ParseText($"using {newUsingReference};" + Environment.NewLine);
                    var newUsingStatementString = newUsingStatementTree.ToString();
                    var newUsingStatement = newUsingStatementTree.GetRoot().ChildNodes().First() as UsingDirectiveSyntax;
                    root = root.AddUsings(newUsingStatement);
                }
            return root;
        }

        /// <summary>
        /// Remove Existing Project References
        /// </summary>
        /// <param name="projectDoc"></param>
        public void RemoveProjectReferences(XElement projectDoc)
        {
            var packageReferences = projectDoc.Elements("ItemGroup")?.Elements("ProjectReference").ToList();
            if (packageReferences != null)
                packageReferences.Remove();
        }

        /// <summary>
        /// Remove existing Package References
        /// </summary>
        /// <param name="projectDoc"></param>
        public void RemovePackageReferences(XElement projectDoc)
        {
            var packageReferences = projectDoc.Elements("ItemGroup")?.Elements("PackageReference").ToList();
            if (packageReferences != null)
                packageReferences.Remove();
        }

        /// <summary>
        /// Add Project References
        /// </summary>
        /// <param name="projectDoc"></param>
        /// <param name="references"></param>
        public void AddProjectReferences(XElement projectDoc, List<string> references)
        {
            if (references == null)
                return;

            var itemGroup = projectDoc.Element("ItemGroup"); // First first ItemGroup
            if (itemGroup == null)
            {
                projectDoc.Add(new XElement("ItemGroup"));
                itemGroup = projectDoc.Element("ItemGroup");
            }

            foreach (var reference in references)
                itemGroup.Add(new XElement("ProjectReference", new XAttribute("Include", reference)));
        }

        /// <summary>
        /// Add Package References
        /// </summary>
        /// <param name="projectDoc"></param>
        /// <param name="references"></param>
        public void AddPackageReferences(XElement projectDoc, Dictionary<string, string> references)
        {
            if (references == null)
                return;

            var itemGroup = projectDoc.Element("ItemGroup"); // First first ItemGroup
            if (itemGroup == null)
            {
                projectDoc.Add(new XElement("ItemGroup"));
                itemGroup = projectDoc.Element("ItemGroup");
            }

            foreach (var reference in references)
                if(string.IsNullOrEmpty(reference.Value))
                    itemGroup.Add(
                        new XElement(
                            "PackageReference",
                            new XAttribute("Include", reference.Key)));
                else
                    itemGroup.Add(
                        new XElement(
                            "PackageReference", 
                            new XAttribute("Include", reference.Key),
                            new XAttribute("Version", reference.Value)));
        }

        private void UpdateProjectProperties(XElement projectDoc, Dictionary<string,string> properties)
        {
            if (properties == null || properties.Count == 0)
                return;

            foreach (var propertyGroup in projectDoc.Elements("PropertyGroup"))
                foreach (var property in propertyGroup.Elements())
                    if (properties.ContainsKey(property.Name.LocalName))
                        property.Value = properties[property.Name.LocalName];
        }


        private void UpdateProjectFile(
            string projFilePath, 
            string projType,
            string projName,
            List<string> localProjectReferences, 
            Dictionary<string,string> localPackageReferences,
            Dictionary<string,string> localProperties
            )
        {
            // Modify csproj
            XElement xmlDoc = XElement.Load(projFilePath);

            RemovePackageReferences(xmlDoc);
            RemoveProjectReferences(xmlDoc);

            // Package References
            var packageReferences = solutionModel.GetConfigProperties($"{projType}/PackageReferences", errorIfMissing: false);
            AddPackageReferences(xmlDoc, packageReferences);

            AddPackageReferences(xmlDoc, localPackageReferences);

            var packageReferences2 = solutionModel.GetConfigProperties($"{projName}/PackageReferences", errorIfMissing: false);
            AddPackageReferences(xmlDoc, packageReferences2);

            // Project References
            var projectReferences = solutionModel.GetConfigPropertyItems($"{projType}/ProjectReferences", errorIfMissing: false);
            AddProjectReferences(xmlDoc, projectReferences);

            AddProjectReferences(xmlDoc, localProjectReferences);

            var projectReferences2 = solutionModel.GetConfigPropertyItems($"{projName}/ProjectReferences", errorIfMissing: false);
            AddProjectReferences(xmlDoc, projectReferences2);

            // Properties
            var projectProperties = solutionModel.GetConfigProperties($"{projType}/Properties", errorIfMissing: false);
            UpdateProjectProperties(xmlDoc, projectProperties);

            UpdateProjectProperties(xmlDoc, localProperties);

            var projectProperties2 = solutionModel.GetConfigProperties($"{projName}/Properties", errorIfMissing: false);
            UpdateProjectProperties(xmlDoc, projectProperties2);

            xmlDoc.Save(projFilePath);
        }

        #region Unused Methods - most were used when using OpenApi-Generator, keep for reference and possible future use
        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax ClearServiceRegistrations(CompilationUnitSyntax root)
        #pragma warning restore IDE0051 // Remove unused private members
        {
            // Update ConfgiureSvcs.cs 
            var projServices = new Dictionary<string, bool>();
            foreach (var key in solutionModel.Lambdas.Keys)
                projServices.Add(key + "Controller", false); // bool indicates if the reference has been registered in the Startup.ConfigureSvcs method


            var method = root
                .DescendantNodes().OfType<ClassDeclarationSyntax>()
                .Where(x => x.Identifier.Text.Equals("Startup"))
                .FirstOrDefault()
                    ?.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Identifier.Text.Equals("ConfigureSvcs")
                            && x.ParameterList.Parameters.Count == 1
                            && x.ParameterList.Parameters[0].Type.ToString().Equals("IServiceCollection"))
                    .First();

            if (method == null)
                throw new Exception("Error: Missing Startup.ConfigureSvcs method");

            var serviceRegistrations = method.DescendantNodes().OfType<BlockSyntax>()
                .First()
                ?.DescendantNodes().OfType<ExpressionStatementSyntax>()
                .Where(x =>
                       (((x.Expression as InvocationExpressionSyntax))?.Expression is MemberAccessExpressionSyntax)
                       && ((((x.Expression as InvocationExpressionSyntax))
                               ?.Expression as MemberAccessExpressionSyntax).Expression as IdentifierNameSyntax)
                                   .Identifier.ValueText.Equals("services"));

            return root.RemoveNodes(serviceRegistrations.ToArray(), SyntaxRemoveOptions.KeepNoTrivia);
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax RemoveUsingStatements(CompilationUnitSyntax root, List<string> usingReferences)
        {
            var existingUsingStatements = root
                .DescendantNodes().OfType<UsingDirectiveSyntax>()
                .ToList();

            var usingStatementsToRemove = new List<string>();
            foreach (var reference in usingReferences)
                usingStatementsToRemove.Add($"using {reference};");

            foreach (var stmt in existingUsingStatements)
                if (usingStatementsToRemove.Contains(stmt.Name.ToString()))
                    root = root.RemoveNode(stmt, SyntaxRemoveOptions.KeepNoTrivia);
            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax InsertConstructor(CompilationUnitSyntax root, string nameSpace, string className, string newConstructorText)
        {

            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl,
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newConstructorText).GetCompilationUnitRoot().Members.ToArray()));
            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax InsertMethods(CompilationUnitSyntax root, string nameSpace, string className, string newMethodText)
        {
            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl,
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newMethodText).GetCompilationUnitRoot().Members.ToArray()));

            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax InsertProperty(CompilationUnitSyntax root, string nameSpace, string className, string newPropertyText)
        {
            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl,
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newPropertyText).GetCompilationUnitRoot().Members.ToArray()));

            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax RemoveConstructors(CompilationUnitSyntax root, string nameSpace, string className)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var constructors = classDecls.DescendantNodes().OfType<ConstructorDeclarationSyntax>();

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(constructors, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax RemoveSyncInterface(CompilationUnitSyntax root, string nameSpace, string className)
        {

            var interfaceDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")); // ex: OrderController

            if (interfaceDecls == null)
                throw new Exception($"Error: Can't find {className}");

            root = root.RemoveNodes(interfaceDecls, SyntaxRemoveOptions.KeepNoTrivia);
            var rootText = root.ToString();
            rootText = rootText.Replace($"{className},", "");
            rootText = rootText.Replace(className, "");
            root = CSharpSyntaxTree.ParseText(rootText).GetCompilationUnitRoot();
            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax RemoveProperty(CompilationUnitSyntax root, string nameSpace, string className, string varName)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var properties = classDecls.DescendantNodes().OfType<PropertyDeclarationSyntax>()
               .Where(x => x.Identifier.ValueText.Equals(varName))
                ;

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(properties, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private CompilationUnitSyntax RemoveSyncMethods(CompilationUnitSyntax root, string nameSpace, string className, List<string> exclude)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var methods = classDecls.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .Where(x => !x.Identifier.ValueText.Contains("Async") && !exclude.Contains(x.Identifier.ValueText));

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(methods, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private void CopyTemplateFolder(string sourceFolder, string targetFolder, Dictionary<string, string> replacements)
        {
            foreach (var clientFile in Directory.EnumerateFiles(sourceFolder))
            {
                var clientFileText = File.ReadAllText(clientFile);
                foreach (var kvp in replacements)
                    clientFileText = clientFileText.Replace(kvp.Key, kvp.Value);

                var newFilePath =
                    (clientFile.EndsWith(".tpl"))
                    ? Path.Combine(targetFolder, Path.GetFileNameWithoutExtension(clientFile)) // remvoed .tpl extension
                    : Path.Combine(targetFolder, Path.GetFileName(clientFile));
                File.WriteAllText(newFilePath, clientFileText);
            }
        }

        #pragma warning disable IDE0051 // Remove unused private members
        private void RemoveTplExtension(string folderName)
        {
            var files = Directory.EnumerateFiles(folderName, "*.tpl");
            foreach (var file in files)
                File.Move(file, Path.GetFileNameWithoutExtension(file));
        }
        #endregion Unused methods
    }
}
