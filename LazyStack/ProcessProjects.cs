using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;

using Microsoft.CodeAnalysis; 
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

using YamlDotNet.RepresentationModel;
using YamlDotNet.Serialization.ObjectGraphTraversalStrategies;
using CommandLine;

namespace LazyStack
{
    /// <summary>
    /// Process the solution projects.
    /// ProcessClientProject -- openApi generation of client Api
    /// ProcessAppApiProject -- openApi generation of core application Api
    /// For Each tag
    ///     ProcessLambdaProject -- create if it doesn't exist
    ///     ProcessControllerProject -- create or update
    /// ProcessLocalWebServer -- update references when new AppApiGroupApi projects are added
    /// </summary>
    public class ProcessProjects
    {
        public ProcessProjects(SolutionModel solutionModel, ILogger logger)
        {
            this.solutionModel = solutionModel;
            this.logger = logger;
        }

        private readonly SolutionModel solutionModel;
        private readonly ILogger logger;

        public void Run()
        {
            ProcessClientSDKProject();

            ProcessSchemaProject(solutionModel.ClientSDK); // generate schema project from client SDK Models

            //ProcessReferenceApiProject();


            // Generate Reference API project using OpenApi Generator
            var projectLib = new GenerateProject(solutionModel)
            {
                Input = solutionModel.OpenApiFilePath,
                Generator = "aspnetcore",
                Output = "", // We don't output this project, we only use pieces of it to generate controllers code
                SkipValidateSpec = true,
                ProjectName = "__ProjectName__"
            };
            var properties = solutionModel.GetConfigProperties("ReferenceApiProjects/OpenApiGeneratorOptions", errorIfMissing: true);
            foreach (var kvp in properties)
                projectLib.AdditionalProperites.Add(kvp.Key, kvp.Value);
            projectLib.AdditionalProperites.Add("packageName", "__ProjectName__");

            try
            {
                projectLib.GenerateTemp(); // This writes the API reference project into a temporary folder

                // We generate Controller and Lambda function project for each
                // tag, in the OpenAPI specification. 

                foreach (KeyValuePair<string, AWSLambda> lambda in solutionModel.Lambdas)
                {
                    var lambdaName = lambda.Key; // ex: Order
                                                 // ex: Lambdas/OrderLambda project
                    ProcessLambdaProject(lambdaName, lambda.Value.AwsApi); // api passed because project needs to know type of Api calling it
                                                                           // ex: Controllers/OrderController project
                    ProcessControllerProject(lambdaName, projectLib.TempSolutionPath);
                }
            }
            finally
            {
                projectLib.RemoveTemp(); // Remove temp folder
            }

            ProcessLocalWebApiProject();

            // Update solutionModel.SolutionFolders
            foreach (var projInfo in solutionModel.Projects.Values)
                if (!string.IsNullOrEmpty(projInfo.SolutionFolder)
                    && !solutionModel.SolutionFolders.Contains(projInfo.SolutionFolder))
                    solutionModel.SolutionFolders.Add(projInfo.SolutionFolder);
        }

        /// <summary>
        /// Generate the <AppName>ClientSDK project.
        /// Also generate the <AppName>Schema project.
        /// The Schema project is the Models folder generated by the 
        /// ClientSDK project. We want the models to be consistent across
        /// the client and server to promote code reuse.
        /// </summary>
        private void ProcessClientSDKProject()
        {
            var appName = solutionModel.AppName; // PetStore
            var projName = $"{appName}ClientSDK";  // PetStoreClientSDK
            var projFileName = $"{projName}.csproj"; // PetStoreClientSDK.csproj 
            var projFileRelativePath = Path.Combine(projName, projFileName); // PetStoreClientSDK/PetStoreClientSDK.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.ClientSDK = new ProjectInfo(
                    solutionFolder: string.Empty,
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    );

            solutionModel.Projects.Add(projName, solutionModel.ClientSDK);
            solutionModel.ClientSDKProjectName = projName;

            logger.Info($"Generating/updating {projName}");

            var client = new GenerateProject(solutionModel)
            {
                Input = solutionModel.OpenApiFilePath,
                Generator = "csharp-netcore",
                Output = solutionModel.SolutionRootFolderPath,
                SkipValidateSpec = true,
                ProjectName = projName
            };

            var properties = solutionModel.GetConfigProperties("ClientSDKProjects/OpenApiGeneratorOptions", errorIfMissing: true);
            foreach (var kvp in properties)
                client.AdditionalProperites.Add(kvp.Key, kvp.Value);
            client.AdditionalProperites.Add("packageName", projName);
            client.Run();

            // Replace Client Folder with our version - replalcing RestSharp with MS Classes, 
            // Implementing AwsSignerVersion4, removing Sync, using MS Configuration
            Directory.Delete(Path.Combine(projFolderPath, "Client"), recursive: true); 

            Utilities.DirectoryCopy(
                Path.Combine(solutionModel.LazyStackTemplateFolderPath, "ClientSDK", "Client"),
                Path.Combine(projFolderPath, "Client"),
                copySubDirs: true,
                overwrite: true,
                removeTplExtension: true,
                new Dictionary<string, string>()
                    {
                        {"__ProjName__", projName }
                    }
                );

            var localProjectReferences =
                new List<string>
                {
                    //< ProjectReference Include = "..\PetStoreSchema\PetStoreSchema.csproj" />
                    Path.Combine("..",$"{appName}Schema", $"{appName}Schema.csproj"),
                };

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "ClientSDKProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );

            // Modify each Api class to use the Schema project and modified Client files
            var files = Directory.EnumerateFiles(Path.Combine(projFolderPath, "Api"));
            foreach (var apiFile in files)
            {
                var fileText = File.ReadAllText(apiFile);
                fileText = fileText.Replace($"using {projName}.Model", $"using {solutionModel.AppName}Schema.Model");
                CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(fileText).GetCompilationUnitRoot();

                var className = Path.GetFileNameWithoutExtension(apiFile);

                root = InsertUsingStatements(
                    root: root,
                    newUsingReferences: new List<string>() 
                    { 
                        "System.ComponentModel.DataAnnotations", 
                        "Microsoft.Extensions.Configuration"}
                    );

                root = RemoveSyncInterface(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: $"I{className}Sync"
                    );

                root = RemoveSyncMethods(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className,
                    exclude: new List<string>()
                    );

                root = RemoveConstructors(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className
                    );

                root = RemoveProperty(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className,
                    varName: "Client"
                    );

                root = RemoveProperty(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className,
                    varName: "Configuration"
                    );


                // Insert new constructor
                var constructorText =
                    $"\t\tpublic {className}(IAsynchronousClient asyncClient)\n" +
                    $"\t\t{{\n" +
                    $"\t\t\tif(asyncClient == null) throw new ArgumentNullException(\"asyncClient\");\n" +
                    $"\t\t\tthis.AsynchronousClient=asyncClient;\n" +
                    $"\t\t}}\n";

                root = InsertConstructor(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className,
                    newConstructorText: constructorText);

                root = InsertProperty(
                    root: root,
                    nameSpace: $"{projName}.Api",
                    className: className,
                    newPropertyText: $"\t\tpublic IConfiguration Configuration {{get; set;}}"
                    );

                fileText = root.ToFullString();
                File.WriteAllText(apiFile, fileText);

            }
        }

        private void ProcessSchemaProject(ProjectInfo clientSDK)
        {
            var projName = $"{solutionModel.AppName}Schema"; // PetStoreSchema
            var projFileName = $"{projName}.csproj"; // PetStoreSchema.csproj
            var projFileRelativePath = Path.Combine(projName, projFileName); // PetStoreSchema/PetStoreSchema.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: string.Empty,
                    path: projFilePath,
                    projFileRelativePath,
                    projFolderPath
                    ));

            logger.Info($"Generating/updating project {projName}");

            if (!Directory.Exists(projFolderPath))
            {
                Utilities.DirectoryCopy(
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Schema"),
                    projFolderPath,
                    copySubDirs: true,
                    overwrite: true,
                    removeTplExtension: true);

                File.Move( // Rename csproj file. ex Lambda.csproj to PetStoreOrderLambda.csproj
                    Path.Combine(projFolderPath, "Schema.csproj"),
                    projFilePath);

                Directory.CreateDirectory(Path.Combine(projFolderPath, "Models"));
            }

            var sourceModelsPath = Path.Combine(clientSDK.FolderPath, "Model");
            if (Directory.Exists(sourceModelsPath))
            {
                // Move ClientSDK models to Schema project
                var files = Directory.EnumerateFiles(sourceModelsPath);
                foreach (var file in files)
                {
                    var classname = Path.GetFileNameWithoutExtension(file);

                    var fileText = File.ReadAllText(file);
                    // Remove reference to OpenApiDateConverter
                    fileText = fileText.Replace($"using OpenAPIDateConverter = {solutionModel.ClientSDKProjectName}.Client.OpenAPIDateConverter;", "");
                    
                    // Rename namespace in model class
                    fileText = fileText.Replace(solutionModel.ClientSDKProjectName, projName);

                    // Replace any protected constructor "protected <classname>() {}" with "public <classname>() {}
                    fileText = fileText.Replace($"protected {classname}()", $"public {classname}()");

                    // Add a parameterless constructor if none exists
                    if (!fileText.Contains($"public {classname}()"))
                    {
                        CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(fileText).GetCompilationUnitRoot();
                        root = InsertConstructor(root, projName + ".Model", classname, $"public {classname}() {{}}");
                        fileText = root.ToFullString();
                    }

                    var newFilePath = Path.Combine(projFolderPath, "Models", Path.GetFileName(file));
                    File.WriteAllText(newFilePath, fileText);
                }
                // Remove sourceModelsPath
                Directory.Delete(sourceModelsPath, recursive: true);
            }
        }

        /// <summary>
        /// Generate the <AppName>Api project.
        /// </summary>
        private void ProcessReferenceApiProject()
        { 
            var projName = $"{solutionModel.AppName}Api"; // PetStoreApi
            var projFileName = $"{projName}.csproj"; // PetStoreApi.csproj
            var projFileRelativePath = Path.Combine(projName, projFileName); // PetStoreApi/PetStoreApi.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);
            var appName = solutionModel.AppName;

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: string.Empty,
                    path: projFilePath,
                    projFileRelativePath,
                    projFolderPath
                    ));

            logger.Info($"Generating/updating project {projName}");
            var projectLib = new GenerateProject(solutionModel)
            {
                Input = solutionModel.OpenApiFilePath,
                Generator = "aspnetcore",
                Output = solutionModel.SolutionRootFolderPath,
                SkipValidateSpec = true,
                ProjectName = projName
            };

            var properties = solutionModel.GetConfigProperties("ReferenceApiProjects/OpenApiGeneratorOptions", errorIfMissing: true);
            foreach (var kvp in properties)
                projectLib.AdditionalProperites.Add(kvp.Key, kvp.Value);
            projectLib.AdditionalProperites.Add("packageName", projName);
            projectLib.Run();

            var localProjectReferences =
                new List<string>
                {
                    //< ProjectReference Include = "..\PetStoreSchema\PetStoreSchema.csproj" />
                    Path.Combine("..",$"{appName}Schema", $"{appName}Schema.csproj"),
                };


            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "ReferenceApiProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );

            // Remove Models folder, we are going to use Schema lib instead
            Directory.Delete(Path.Combine(projFolderPath, "Models"), recursive: true);

            // Update Api class files
            var files = Directory.EnumerateFiles(Path.Combine(projFolderPath, "Controllers"));
            foreach (var file in files)
            {
                var fileText = File.ReadAllText(file);
                fileText = fileText.Replace($"using {projName}.Models", $"using {solutionModel.AppName}Schema.Model");
                File.WriteAllText(file, fileText);
            }
        }

        /// <summary>
        /// Generate the Lambdas/<LambdaName>Lambda project.
        /// </summary>
        /// <param name="lambdaName"></param>
        /// <paramref name="api"/>
        /// <paramref name="tempApiSolutionPath"/>
        private void ProcessLambdaProject(string lambdaName, AwsApi api)
        {
            // Create Lambda project
            // LazyStack Templates contains a simple project fileset that we copy and 
            // modify to create the Func project. The Func project will reference the
            // <LambdaName>Api project. Programmers do not need to add anything to
            // these projects.
            var projName = $"{lambdaName}";
            var projFileName = $"{projName}.csproj";
            var projFileRelativePath = Path.Combine("Lambdas", projName, projFileName);
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, "Lambdas", projName);
            var projFilePath = Path.Combine(projFolderPath, $"{lambdaName}.csproj");

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: "Lambdas",
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    ));

            logger.Info($"Generating/updating project {projName}");

            if (!Directory.Exists(projFolderPath))
            {
                Utilities.DirectoryCopy(
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda"),
                    projFolderPath,
                    copySubDirs: true,
                    overwrite: true,
                    removeTplExtension: true);

                File.Move( // Rename csproj file. ex Lambda.csproj to PetStoreOrderLambda.csproj
                    Path.Combine(projFolderPath, "Lambda.csproj"),
                    projFilePath);

            }

            var configureSvcsFilePath = Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda", "ConfigureSvcs.cs.tpl");
            var configureSvcsText = File.ReadAllText(configureSvcsFilePath);
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(configureSvcsText).GetCompilationUnitRoot();

            var serviceStatements = solutionModel.GetConfigPropertyItems($"LambdaProjects/ServiceRegistrations", errorIfMissing: false);
            var serviceStatements2 = solutionModel.GetConfigPropertyItems($"{projName}/ServiceRegistrations", errorIfMissing: false);
            foreach (var stmt in serviceStatements2)
                if (!serviceStatements.Contains(stmt))
                    serviceStatements.Add(stmt);
            FormatServiceStatements(serviceStatements);

            root = InsertServiceRegistrations(root, serviceStatements);
            configureSvcsText = root.ToFullString();
            var filePath = Path.Combine(projFolderPath, "ConfigureSvcs.cs");
            File.WriteAllText(filePath, configureSvcsText);


            // Update LambdaEntryPoint class to inherit correct base class for specified HttpApi or Api
            // We do this every time because it is not unusual to change the tag/api mapping
            var text = File.ReadAllText(Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Lambda", "LambdaEntryPoint.cs.tpl"));
            var baseClass = api.ProxyFunctionName;
            text = text.Replace("__APIGatewayProxyFunction__", baseClass);
            var lamdbaEntryPointFilePath = Path.Combine(projFolderPath, "LambdaEntryPoint.cs");
            File.WriteAllText(lamdbaEntryPointFilePath, text);

            var localProjectReferences =
                new List<string>
                {
                    //< ProjectReference Include = "..\..\Controllers\OrderController\OrderController.csproj" />
                    Path.Combine("..","..","Controllers",$"{lambdaName}Controller", $"{lambdaName}Controller.csproj")
                };

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "LambdaProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );

        }

        /// <summary>
        /// Generate a <LambdaName></LambdaName>Controller project.
        /// </summary>
        /// <param name="lambdaName"></param>
        private void ProcessControllerProject(string lambdaName, string tempApiSolutionPath)
        {
            var appName = solutionModel.AppName; // PetStore
            var projName = $"{lambdaName}Controller"; // OrderController
            var projFileName = $"{projName}.csproj"; // OrderController.csproj
            var projFileRelativePath = Path.Combine("Controllers", projName, projFileName); // Controllers/OrderController/OrderController.csproj
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, "Controllers", projName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            solutionModel.Projects.Add(projName,
                new ProjectInfo(
                    solutionFolder: "Controllers",
                    path: projFilePath,
                    relativePath: projFileRelativePath,
                    folderPath: projFolderPath
                    ));


            logger.Info($"Generating/updating project {lambdaName}Controller");

            // Create new project folder if it doesn't exist
            if (!Directory.Exists(projFolderPath))
            {
                Directory.CreateDirectory(projFolderPath);

                File.Move( // Rename csproj file. ex: ApiController.csproj to OrderController.csproj
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Controllers", "Controller.csproj"),
                    projFilePath);
            }

            var classFilePath = Path.Combine(projFolderPath, $"{lambdaName}Controller.cs");

            if (!File.Exists(classFilePath))
            {
                // Create Class file
                // ex: Rename Controller.cs to .cs ex: OrderController.cs
                File.Move(
                    Path.Combine(solutionModel.LazyStackTemplateFolderPath, "Controllers", "Controller.cs.tpl"),
                    classFilePath
                    );

                var text = File.ReadAllText(classFilePath);
                var usingStatements =
                    $"using {appName}Schema.Model;\n"; // ex: using PetStoreSchema.Model;

                text = text.Replace("__UsingStatements__", usingStatements);
                text = text.Replace("__LambdaNameController__", $"{lambdaName}Controller"); // ex: OrderController
                text = text.Replace("__LambdaNameApiController__", $"{lambdaName}ApiController"); //ex: OrderApiController

                var apiMethods = ProcessApiControllerClass(appName, lambdaName, tempApiSolutionPath, projFolderPath);
                text = text.Replace("__Methods__", GenerateControllerMethods(apiMethods));
                File.WriteAllText(classFilePath, text);
            }
            else
            {
                // Update methods
                // Copy the controller virtual class, and supporting classes, to the controller project
                var apiMethods = ProcessApiControllerClass(appName, lambdaName, tempApiSolutionPath, projFolderPath);

                var existingMethods = GetControllerMethods(lambdaName);
                var insertMethods = new List<Method>();
                foreach (var m in apiMethods)
                {
                    bool found = false;
                    foreach (var em in existingMethods)
                        if (m.MethodName.Equals(em.MethodName) && m.Arguments.Equals(em.Arguments))
                        {
                            found = true;
                            break;
                        }
                    if (!found)
                        insertMethods.Add(m);
                }
                if (insertMethods.Count > 0)
                    InsertMethodsInFile($"{lambdaName}Controller", $"{lambdaName}Controller", classFilePath, GenerateControllerMethods(insertMethods));
            }

            var localProjectReferences =
                new List<string> {
                    //< ProjectReference Include = "..\PetStoreSchema\PetStoreSchema.csproj" />
                    Path.Combine("..","..",$"{appName}Schema", $"{appName}Schema.csproj"),
                };

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "ControllerProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );

        }

        private void ProcessLocalWebApiProject()
        {
            // Local web server
            var appName = solutionModel.AppName;
            var projName = appName;
            var projFileName = $"{projName}.csproj";
            var projFolderPath = Path.Combine(solutionModel.SolutionRootFolderPath, appName);
            var projFilePath = Path.Combine(projFolderPath, projFileName);

            logger.Info($"Updating project {appName}");

            var configureSvcsFilePath = Path.Combine(solutionModel.LazyStackTemplateFolderPath, "WebApi", "ConfigureSvcs.cs.tpl");
            var configureSvcsText = File.ReadAllText(configureSvcsFilePath);
            configureSvcsText = configureSvcsText.Replace("__NameSpace__", projName);
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(configureSvcsText).GetCompilationUnitRoot();

            var serviceStatements = solutionModel.GetConfigPropertyItems($"WebApiProjects/ServiceRegistrations", errorIfMissing: false);
            var serviceStatements2 = solutionModel.GetConfigPropertyItems($"{projName}/ServiceRegistrations", errorIfMissing: false);
            foreach (var stmt in serviceStatements2)
                if (!serviceStatements.Contains(stmt))
                    serviceStatements.Add(stmt);
            FormatServiceStatements(serviceStatements);

            root = InsertServiceRegistrations(root, serviceStatements);
            configureSvcsText = root.ToFullString();
            var filePath = Path.Combine(projFolderPath, "ConfigureSvcs.cs");
            File.WriteAllText(filePath, configureSvcsText);


            var localProjectReferences = new List<string>();
            foreach (var lambdaName in solutionModel.Lambdas.Keys)
                // ex: <ProjectReference Include="..\Controllers\OrderController\OrderController.csproj"/>
                localProjectReferences.Add(Path.Combine("..", "Controllers", $"{lambdaName}Controller", $"{lambdaName}Controller.csproj"));

            // Modify csproj
            UpdateProjectFile(
                projFilePath,
                "WebApiProjects",
                projName,
                localProjectReferences: localProjectReferences,
                localPackageReferences: null,
                localProperties: null
                );
        }

        private void FormatServiceStatements(List<string> serviceStatements)
        {
            for (int i = 0; i < serviceStatements.Count; i++)
                serviceStatements[i] = $"            {serviceStatements[i]}\n";
        }

        private void ClearServiceRegistrationsInFile(string filePath)
        {
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(File.ReadAllText(filePath)).GetCompilationUnitRoot();
            root = ClearServiceRegistrations(root);
            File.WriteAllText(filePath, root.ToFullString());
        }

        private CompilationUnitSyntax ClearServiceRegistrations(CompilationUnitSyntax root)
        {
            // Update ConfgiureSvcs.cs 
            var projServices = new Dictionary<string, bool>();
            foreach (var key in solutionModel.Lambdas.Keys)
                projServices.Add(key + "Controller", false); // bool indicates if the reference has been registered in the Startup.ConfigureSvcs method


            var method = root
                .DescendantNodes().OfType<ClassDeclarationSyntax>()
                .Where(x => x.Identifier.Text.Equals("Startup"))
                .FirstOrDefault()
                    ?.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Identifier.Text.Equals("ConfigureSvcs")
                            && x.ParameterList.Parameters.Count == 1
                            && x.ParameterList.Parameters[0].Type.ToString().Equals("IServiceCollection"))
                    .First();

            if (method == null)
                throw new Exception("Error: Missing Startup.ConfigureSvcs method");

            var serviceRegistrations = method.DescendantNodes().OfType<BlockSyntax>()
                .First()
                ?.DescendantNodes().OfType<ExpressionStatementSyntax>()
                .Where(x =>
                       (((x.Expression as InvocationExpressionSyntax))?.Expression is MemberAccessExpressionSyntax)
                       && ((((x.Expression as InvocationExpressionSyntax))
                               ?.Expression as MemberAccessExpressionSyntax).Expression as IdentifierNameSyntax)
                                   .Identifier.ValueText.Equals("services"));

            return root.RemoveNodes(serviceRegistrations.ToArray(), SyntaxRemoveOptions.KeepNoTrivia);
        }

        private void InsertServiceRegistrationsInFile(string filePath, List<string> serviceStatements)
        {
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(File.ReadAllText(filePath)).GetCompilationUnitRoot();
            root = InsertServiceRegistrations(root, serviceStatements);
            File.WriteAllText(filePath, root.ToFullString());
        }

        private CompilationUnitSyntax InsertServiceRegistrations(CompilationUnitSyntax root, List<string> serviceStatements)
        {
            // Update ConfgiureSvcs.cs 
            var projServices = new Dictionary<string, bool>();
            foreach (var key in solutionModel.Lambdas.Keys)
                projServices.Add(key + "Controller", false); // bool indicates if the reference has been registered in the Startup.ConfigureSvcs method

            var method = root
                .DescendantNodes().OfType<ClassDeclarationSyntax>()
                .Where(x => x.Identifier.Text.Equals("Startup"))
                .FirstOrDefault()
                    ?.DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .Where(x => x.Identifier.Text.Equals("ConfigureSvcs")
                            && x.ParameterList.Parameters.Count == 1
                            && x.ParameterList.Parameters[0].Type.ToString().Equals("IServiceCollection"))
                    .First();

            if (method == null)
                throw new Exception("Error: Missing Startup.ConfigureSvcs method");

            var serviceRegistrations = method.DescendantNodes().OfType<BlockSyntax>()
                .First()
                ?.DescendantNodes().OfType<ExpressionStatementSyntax>()
                .Where(x =>
                       (((x.Expression as InvocationExpressionSyntax))?.Expression is MemberAccessExpressionSyntax)
                       && ((((x.Expression as InvocationExpressionSyntax))
                               ?.Expression as MemberAccessExpressionSyntax).Expression as IdentifierNameSyntax)
                                   .Identifier.ValueText.Equals("services"));

            // Insert service registrations
            var newStatements = new List<StatementSyntax>();
            foreach (var serviceStatement in serviceStatements)
                newStatements.Add(ParseStatement(serviceStatement));

            if (newStatements.Count > 0)
                root = root.ReplaceNode(method, method.AddBodyStatements(newStatements.ToArray()));

            return root;
        }

        private CompilationUnitSyntax InsertUsingStatements(CompilationUnitSyntax root, List<string> newUsingReferences)
        {
            var existingUsingStatements = root
                .DescendantNodes().OfType<UsingDirectiveSyntax>();

            var existingUsingStatementsList = new List<string>();
            foreach (var stmt in existingUsingStatements)
                existingUsingStatementsList.Add(stmt.Name.ToString());

            foreach (var newUsingReference in newUsingReferences)
                if (existingUsingStatementsList.Count == 0 || !existingUsingStatementsList.Contains($"using {newUsingReference};"))
                {
                    var newUsingStatementTree = CSharpSyntaxTree.ParseText($"using {newUsingReference};" + Environment.NewLine);
                    var newUsingStatementString = newUsingStatementTree.ToString();
                    var newUsingStatement = newUsingStatementTree.GetRoot().ChildNodes().First() as UsingDirectiveSyntax;
                    root = root.AddUsings(newUsingStatement);
                }
            return root;
        }

        private CompilationUnitSyntax RemoveUsingStatements(CompilationUnitSyntax root, List<string> usingReferences)
        {
            var existingUsingStatements = root
                .DescendantNodes().OfType<UsingDirectiveSyntax>()
                .ToList();

            var usingStatementsToRemove= new List<string>();
            foreach (var reference in usingReferences)
                usingStatementsToRemove.Add($"using {reference};");

            foreach (var stmt in existingUsingStatements)
                if (usingStatementsToRemove.Contains(stmt.Name.ToString()))
                    root = root.RemoveNode(stmt, SyntaxRemoveOptions.KeepNoTrivia);
            return root;
        }

        private CompilationUnitSyntax InsertConstructor(CompilationUnitSyntax root, string nameSpace, string className, string newConstructorText)
        {

            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl,
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newConstructorText).GetCompilationUnitRoot().Members.ToArray()));
            return root;
        }

        private void InsertMethodsInFile(string nameSpace, string className, string fileName, string newMethodText)
        {
            var root = CSharpSyntaxTree.ParseText(File.ReadAllText(fileName)).GetCompilationUnitRoot();
            root = InsertMethods(root, nameSpace, className, newMethodText);
            File.WriteAllText(fileName, root.ToString());
        }

        private CompilationUnitSyntax InsertMethods(CompilationUnitSyntax root, string nameSpace, string className, string newMethodText)
        {
            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl, 
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newMethodText).GetCompilationUnitRoot().Members.ToArray()));

            return root;
        }

        private CompilationUnitSyntax InsertProperty(CompilationUnitSyntax root, string nameSpace, string className, string newPropertyText)
        {
            var classDecl = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals(nameSpace))
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals(className))
                    .First();

            if (classDecl == null)
                throw new Exception($"Error: Can't find {nameSpace}.{className}");

            root = root.ReplaceNode(classDecl,
                classDecl.AddMembers(CSharpSyntaxTree.ParseText(newPropertyText).GetCompilationUnitRoot().Members.ToArray()));

            return root;
        }

        private CompilationUnitSyntax RemoveConstructors(CompilationUnitSyntax root, string nameSpace, string className)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var constructors = classDecls.DescendantNodes().OfType<ConstructorDeclarationSyntax>();

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(constructors, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        private CompilationUnitSyntax RemoveSyncInterface(CompilationUnitSyntax root, string nameSpace, string className)
        {

            var interfaceDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<InterfaceDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")); // ex: OrderController

            if (interfaceDecls == null)
                throw new Exception($"Error: Can't find {className}");

            root = root.RemoveNodes(interfaceDecls, SyntaxRemoveOptions.KeepNoTrivia);
            var rootText = root.ToString();
            rootText = rootText.Replace($"{className},", "");
            rootText = rootText.Replace(className, "");
            root = CSharpSyntaxTree.ParseText(rootText).GetCompilationUnitRoot();
            return root;
        }

        private CompilationUnitSyntax RemoveProperty(CompilationUnitSyntax root, string nameSpace, string className, string varName)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var properties = classDecls.DescendantNodes().OfType<PropertyDeclarationSyntax>()
               .Where(x => x.Identifier.ValueText.Equals(varName))
                ;

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(properties, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        private CompilationUnitSyntax RemoveSyncMethods(CompilationUnitSyntax root, string nameSpace, string className, List<string> exclude)
        {
            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{nameSpace}")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{className}")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {className}");

            var methods = classDecls.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .Where(x => !x.Identifier.ValueText.Contains("Async") && !exclude.Contains(x.Identifier.ValueText));

            root = root.ReplaceNode(classDecls,
                classDecls.RemoveNodes(methods, SyntaxRemoveOptions.KeepNoTrivia));

            return root;
        }

        private void CopyTemplateFolder(string sourceFolder, string targetFolder, Dictionary<string,string> replacements)
        {
            foreach (var clientFile in Directory.EnumerateFiles(sourceFolder))
            {
                var clientFileText = File.ReadAllText(clientFile);
                foreach(var kvp in replacements)
                    clientFileText = clientFileText.Replace(kvp.Key, kvp.Value);

                var newFilePath =
                    (clientFile.EndsWith(".tpl"))
                    ? Path.Combine(targetFolder, Path.GetFileNameWithoutExtension(clientFile)) // remvoed .tpl extension
                    : Path.Combine(targetFolder, Path.GetFileName(clientFile));
                File.WriteAllText(newFilePath, clientFileText);
            }
        }

        private void RemoveTplExtension(string folderName)
        {
            var files = Directory.EnumerateFiles(folderName, "*.tpl");
            foreach (var file in files)
                File.Move(file, Path.GetFileNameWithoutExtension(file));
        }


        private List<Method> ProcessApiControllerClass(string appName, string lambdaName, string tempApiSolutionPath, string targetFolderPath)
        {
            // Virtual Class
            var srcProjectFolder = Path.Combine(tempApiSolutionPath, "src", "__ProjectName__");
            var fileText = File.ReadAllText(Path.Combine(srcProjectFolder, "Controllers", $"{lambdaName}Api.cs"));
            fileText = "// LazyStack Generated file, any changes will be overwritten\n" + fileText;
            fileText = fileText.Replace("__ProjectName__.Controllers", $"{lambdaName}Controller");
            fileText = fileText.Replace("using __ProjectName__.Attributes;", "");
            fileText = fileText.Replace("using __ProjectName__.Models;", $"using {appName}Schema.Model;");
            File.WriteAllText(Path.Combine(targetFolderPath, $"{lambdaName}Api.cs"), fileText);

            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(fileText).GetCompilationUnitRoot();

            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{lambdaName}Controller")) // ex: PetController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{lambdaName}ApiController"))
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {lambdaName}ApiController class");

            var methods = classDecls.DescendantNodes().OfType<MethodDeclarationSyntax>();

            var methodList = new List<Method>();
            foreach (var method in methods)
                methodList.Add(new Method(
                    methodSummary: method.GetLeadingTrivia().ToString(),
                    returnType: method.ReturnType.ToString(),
                    methodName: method.Identifier.ValueText,
                    arguments: method.ParameterList.ToString()
                    ));

            // Copy supporting classes
            fileText = File.ReadAllText(Path.Combine(srcProjectFolder, "Attributes", "ValidateModelStateAttribute.cs"));
            fileText = "// LazyStack Generated file, any changes will be overwritten\n" + fileText;
            fileText = fileText.Replace("__ProjectName__.Attributes", $"{lambdaName}Controller");
            File.WriteAllText(Path.Combine(targetFolderPath, "ValidateModelStateAttribute.cs"), fileText);

            fileText = File.ReadAllText(Path.Combine(srcProjectFolder, "Converters", "CustomEnumConverter.cs"));
            fileText = "// LazyStack Generated file, any changes will be overwritten\n" + fileText;
            fileText = fileText.Replace("__ProjectName__.Converters", $"{lambdaName}Controller");
            File.WriteAllText(Path.Combine(targetFolderPath, "CustomEnumConverter.cs"), fileText);

            return methodList;

        }


        /// <summary>
        /// Get methods from AppNameApi reference project for a specified class name
        /// </summary>
        /// <param name="lambdaName"></param>
        /// <returns></returns>
        private List<Method> GetApiControllerMethods(string lambdaName)
        {

            // ex: PetStoreApi/Controllers/OrderApi.cs
            var fileText = File.ReadAllText(
                Path.Combine(solutionModel.SolutionRootFolderPath, 
                $"{solutionModel.AppName}Api", 
                "Controllers", $"{lambdaName}Api.cs"));

            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(fileText).GetCompilationUnitRoot();

            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{solutionModel.AppName}Api.Controllers")) // ex: PetStoreApi.Controllers
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{lambdaName}ApiController"))
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {lambdaName}ApiController class");

            var methods = classDecls.DescendantNodes().OfType<MethodDeclarationSyntax>();
                
            var methodList = new List<Method>();
            foreach (var method in methods)
                methodList.Add(new Method(
                    methodSummary: method.GetLeadingTrivia().ToString(),
                    returnType: method.ReturnType.ToString(),
                    methodName: method.Identifier.ValueText,
                    arguments: method.ParameterList.ToString()
                    ));

            return methodList;
        }

        private List<Method> GetControllerMethods(string lambdaName)
        {
            // ex: Controllers/OrderApiController/OrderApiController.cs
            var fileText = File.ReadAllText(
                Path.Combine(solutionModel.SolutionRootFolderPath, 
                "Controllers", 
                $"{lambdaName}Controller", 
                $"{lambdaName}Controller.cs"));

            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(fileText).GetCompilationUnitRoot();

            var classDecls = root
                .DescendantNodes().OfType<NamespaceDeclarationSyntax>()
                .Where(x => x.Name.ToString().Equals($"{lambdaName}Controller")) // ex: OrderController
                .First()
                    ?.DescendantNodes().OfType<ClassDeclarationSyntax>()
                    .Where(x => x.Identifier.ValueText.Equals($"{lambdaName}Controller")) // ex: OrderController
                    .First();

            if (classDecls == null)
                throw new Exception($"Error: Can't find {lambdaName}Controller");

            var methods = classDecls.DescendantNodes().OfType<MethodDeclarationSyntax>();

            var methodList = new List<Method>();
            foreach (var method in methods)
                methodList.Add(new Method(
                    methodSummary: method.GetLeadingTrivia().ToString(),
                    returnType: method.ReturnType.ToString(),
                    methodName: method.Identifier.ValueText,
                    arguments: method.ParameterList.ToString()
                    ));

            return methodList;
        }

        private string GenerateControllerMethods(List<Method> methods)
        {
            var text = string.Empty;
            foreach (var m in methods)
                text += m.GenerateControllerMethodDef();
            return text;
        }

        /// <summary>
        /// Parsed Method
        /// </summary>
        private class Method
        {
            public Method(string methodSummary, string returnType, string methodName, string arguments)
            {
                MethodSummary = methodSummary;
                ReturnType = returnType;
                MethodName = methodName;
                Arguments = arguments;

                if (!string.IsNullOrEmpty(arguments))
                {
                    var noAnnotationsRegEx = new Regex(@"\[.*?\]", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                    ArgumentsNoAnnotations = noAnnotationsRegEx.Replace(arguments, String.Empty);
                    var argValuePairsRegEx = new Regex(@"[\w<>]+", RegexOptions.Compiled | RegexOptions.IgnoreCase);

                    var argValuePairs = argValuePairsRegEx.Matches(ArgumentsNoAnnotations);
                    bool argValue = false;
                    bool firstValue = true;
                    foreach (var am in argValuePairs)
                    {
                        if (argValue)
                        {
                            ArgName.Add(am.ToString());
                            ArgList += (firstValue) ? am.ToString() : ", " + am.ToString();
                            firstValue = false;
                            argValue = false;
                        }
                        else
                        {
                            argValue = true;
                            ArgType.Add(am.ToString());
                        }
                    }
                }
            }

            #region Properties
            /// <summary>
            /// Return type of method
            /// </summary>
            public string ReturnType { get; }

            /// <summary>
            /// Method Summary text
            /// </summary>
            public string MethodSummary { get; }

            /// <summary>
            ///  Method Name
            /// </summary>
            public string MethodName { get; }

            /// <summary>
            /// Arguments list with annotations. 
            /// </summary>
            public string Arguments { get; } = String.Empty;

            /// <summary>
            /// Argument list without annotations
            /// </summary>            
            public string ArgumentsNoAnnotations { get; } = String.Empty;

            /// <summary>
            /// Array of Argument types
            /// </summary>
            public List<string> ArgType { get; } = new List<string>();

            /// <summary>
            /// 
            /// Array of Argyment names
            /// </summary>
            public List<string> ArgName { get; } = new List<string>();

            /// <summary>
            /// Comma separate list of argument names
            /// </summary>
            public string ArgList { get; } = String.Empty;
            #endregion

            #region Methods
            public string GenerateControllerMethodDef()
            {
                //        //+lz DeleteOrder([FromRoute][Required]long orderId)
                //        /// <summary>
                //        /// Delete purchase order by ID
                //        /// </summary>
                //        /// <remarks>For valid response try integer IDs with positive integer value.\\ \\ Negative or non-integer values will generate API errors</remarks>
                //        /// <param name="orderId">ID of the order that needs to be deleted</param>
                //        /// <response code="400">Invalid ID supplied</response>
                //        /// <response code="404">Order not found</response>
                //        /// [HttpDelete]
                //        /// [Route("/order/{orderId}")]
                //        /// [ValidateModelState]
                //        //-lz
                //         public override async IActionResult DeleteOrder([FromRoute][Required]long orderId)
                //         {
                //             throw new NotImplementedException("DeleteOrder not implemented in Svcs library");
                //         }
                string newSummary = string.Empty;
                if(!string.IsNullOrEmpty(MethodSummary))
                {
                    var lines = MethodSummary.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries);
                    // Trim leading spaces
                    int i = 0;
                    for (; i < lines.Length; i++)
                        lines[i] = lines[i].Trim();

                    var newLines = new List<string> { $"\t\t//+lz {MethodName} {Arguments}\n" };
                    foreach (var line in lines)
                        if (line.Length > 0)
                            if (line.StartsWith("/"))
                                newLines.Add($"\t\t{line}\n");
                            else
                                newLines.Add($"\t\t/// {line}\n");

                    newLines.Add($"\t\t//-lz\n");
                    newSummary = string.Concat(newLines);
                }

                var method = 
                    newSummary +
                    $"\t\tpublic override async {ReturnType} {MethodName} {Arguments}\n" +
                    $"\t\t{{\n\t\t\tthrow new NotImplementedException(\"{MethodName} not implemented in Controller\");\n\t\t}}\n\n";
                return method;
            }
            #endregion
        }

        public void RemoveProjectReferences(XElement projectDoc)
        {
            var packageReferences = projectDoc.Elements("ItemGroup")?.Elements("ProjectReference").ToList();
            if (packageReferences != null)
                packageReferences.Remove();
        }

        public void RemovePackageReferences(XElement projectDoc)
        {
            var packageReferences = projectDoc.Elements("ItemGroup")?.Elements("PackageReference").ToList();
            if (packageReferences != null)
                packageReferences.Remove();
        }

        public void UpdateProjectReferences(XElement projectDoc, List<string> references)
        {
            if (references == null)
                return;

            var itemGroup = projectDoc.Element("ItemGroup"); // First first ItemGroup
            if (itemGroup == null)
            {
                projectDoc.Add(new XElement("ItemGroup"));
                itemGroup = projectDoc.Element("ItemGroup");
            }

            foreach (var reference in references)
                itemGroup.Add(new XElement("ProjectReference", new XAttribute("Include", reference)));
        }

        public void UpdatePackageReferences(XElement projectDoc, Dictionary<string, string> references)
        {
            if (references == null)
                return;

            var itemGroup = projectDoc.Element("ItemGroup"); // First first ItemGroup
            if (itemGroup == null)
            {
                projectDoc.Add(new XElement("ItemGroup"));
                itemGroup = projectDoc.Element("ItemGroup");
            }

            foreach (var reference in references)
                itemGroup.Add(
                    new XElement(
                        "PackageReference", 
                        new XAttribute("Include", reference.Key),
                        new XAttribute("Version", reference.Value)));
        }

        private void UpdateProjectProperties(XElement projectDoc, Dictionary<string,string> properties)
        {
            if (properties == null || properties.Count == 0)
                return;

            foreach (var propertyGroup in projectDoc.Elements("PropertyGroup"))
                foreach (var property in propertyGroup.Elements())
                    if (properties.ContainsKey(property.Name.LocalName))
                        property.Value = properties[property.Name.LocalName];
        }

        private void UpdateProjectFile(
            string projFilePath, 
            string projType,
            string projName,
            List<string> localProjectReferences, 
            Dictionary<string,string> localPackageReferences,
            Dictionary<string,string> localProperties
            )
        {
            // Modify csproj
            XElement xmlDoc = XElement.Load(projFilePath);

            RemovePackageReferences(xmlDoc);
            RemoveProjectReferences(xmlDoc);

            // Package References
            var packageReferences = solutionModel.GetConfigProperties($"{projType}/PackageReferences", errorIfMissing: false);
            UpdatePackageReferences(xmlDoc, packageReferences);

            UpdatePackageReferences(xmlDoc, localPackageReferences);

            var packageReferences2 = solutionModel.GetConfigProperties($"{projName}/PackageReferences", errorIfMissing: false);
            UpdatePackageReferences(xmlDoc, packageReferences2);

            // Project References
            var projectReferences = solutionModel.GetConfigPropertyItems($"{projType}/ProjectReferences", errorIfMissing: false);
            UpdateProjectReferences(xmlDoc, projectReferences);

            UpdateProjectReferences(xmlDoc, localProjectReferences);

            var projectReferences2 = solutionModel.GetConfigPropertyItems($"{projName}/ProjectReferences", errorIfMissing: false);
            UpdateProjectReferences(xmlDoc, projectReferences2);

            // Properties
            var projectProperties = solutionModel.GetConfigProperties($"{projType}/Properties", errorIfMissing: false);
            UpdateProjectProperties(xmlDoc, projectProperties);

            UpdateProjectProperties(xmlDoc, localProperties);

            var projectProperties2 = solutionModel.GetConfigProperties($"{projName}/Properties", errorIfMissing: false);
            UpdateProjectProperties(xmlDoc, projectProperties2);

            xmlDoc.Save(projFilePath);
        }
    }

    public class GenerateProject
    {
        public GenerateProject(SolutionModel solutionModel)
        {
            this.solutionModel = solutionModel;
        }

        public string Input { get; set; }
        public string Generator { get; set; }
        public string Output { get; set; }
        public bool SkipValidateSpec { get; set; }
        public Dictionary<String, String> AdditionalProperites { get; set; } = new Dictionary<string, string>();
        public string ProjectName { get; set; }
        public string TempSolutionPath { get; set; }
        readonly SolutionModel solutionModel;

        public void Run()
        {
            GenerateTemp();
            CopyToOutput();
            RemoveTemp();
        }

        public void GenerateTemp()
        {
            // We use OpenApiGenerator to generate projects
            // OpenApiGenerator creates a complete solution (which we do not need)
            // as well as the required project. So we generate into a 
            // temp folder, copy the project content we want to
            // the specified output folder and then remove the generated solution from
            // the temporary folder.

            var tempFolder = Path.Combine(Path.GetTempPath(),"LazyStack");

            // First Create LazyStack temp folder if it doesn't exist
            if (!Directory.Exists(tempFolder))
                Directory.CreateDirectory(tempFolder);

            TempSolutionPath = Path.Combine(tempFolder,Guid.NewGuid().ToString());
            if (!Directory.Exists(TempSolutionPath))
                Directory.CreateDirectory(TempSolutionPath);

            using (System.Diagnostics.Process pProcess = new System.Diagnostics.Process())
            {
                pProcess.StartInfo.FileName = @"java.exe";

                var arguments = $"-jar \"{solutionModel.OpenApiGeneratorFilePath}\" generate -i \"{Input}\" -g \"{Generator}\" -o \"{TempSolutionPath}\"";
                if (SkipValidateSpec)
                    arguments += " --skip-validate-spec";

                string props = String.Empty;
                bool first = true;
                foreach (KeyValuePair<string, string> kvp in AdditionalProperites)
                {
                    props += (first) ? $" --additional-properties={kvp.Key}={kvp.Value}" : $",{kvp.Key}={kvp.Value}";
                    first = false;
                }

                //if (!string.IsNullOrEmpty(props))
                //    pProcess.StartInfo.ArgumentList.Add(props);

                if (!string.IsNullOrEmpty(props))
                    arguments += props;

                pProcess.StartInfo.Arguments = arguments;

                pProcess.StartInfo.UseShellExecute = false;
                pProcess.StartInfo.RedirectStandardOutput = true;
                pProcess.StartInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Normal;
                pProcess.StartInfo.CreateNoWindow = true; //do not display a window
                Debug.WriteLine($"Calling openapi-generagor {arguments}");
                pProcess.Start();
                StreamReader reader = pProcess.StandardOutput;
                string output = reader.ReadToEnd();
                pProcess.WaitForExit();
                Debug.WriteLine($"{output}");
                Debug.WriteLine($"Exit Code: {pProcess.ExitCode}");
            }
        }

        public void CopyToOutput()
        {
            if (Directory.Exists(TempSolutionPath))
            {
                // Copy the project to the specified output folder
                var srcProjectFolderPath = Path.Combine(TempSolutionPath, "src", ProjectName);
                var tarProjectFolderPath = Path.Combine(Output, ProjectName);
                Utilities.DirectoryCopy(srcProjectFolderPath, tarProjectFolderPath, true, true);
            }
        }

        public void RemoveTemp()
        {
            // Remove the temporary solution folder
            if (Directory.Exists(TempSolutionPath))
                Directory.Delete(TempSolutionPath, true);
        }
    }
}
